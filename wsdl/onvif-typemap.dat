# Added import to support WS-Security
[
#import "wsse.h"
#import "wsdd.h"
#import "wsa5.h"
]

#########
#
# Below is a copy from /usr/share/gsoap/WS/typemap.dat
#
#########


#       typemap.dat

#       Use this file to define XML namespace prefixes and type bindings for
#       interface header files generated by the wsdl2h tool.
#
#       This typemap.dat file is the default file used by wsdl2h to customize
#       its output. You can use wsdl2h option -t to specify an alternate file.

####### XML NAMESPACE BINDINGS

#       You can define XML namespace prefix bindings to override the default
#       choice of the ns1, ns2, ... prefixes generated by wsdl2h.  It is highly
#       recommended to provide namespace prefixes for your project's XML
#       namespaces.  In this way, changes to the WSDL (or newer releases of
#       wsdl2h) will have a minimal impact on coding and project maintenance.
#
#       Bindings for namespace prefixes are of the form:
#
#               prefix = "URI"
#
#       For example, to bind prefix s3 to the AWS S3 namespace:
#
#               s3 = "http://s3.amazonaws.com/doc/2006-03-01/"

####### XSD TYPE BINDINGS

#       Type bindings can be provided to bind XML schema types to C/C++
#       types for your project.
#
#       Type bindings are of the form:
#
#               prefix__type = declaration | use | ptr-use
#
#       where 'prefix__type' is the C/C++-translation of the schema type,
#       'declaration' introduces the type in the header file, the optional
#       'use' specifies how the type is used directly, and the optional
#       'ptr-use' specifies how the type is used as a pointer type.
#
#       For example, to use wide strings in C:
#
#               xsd__string = | wchar_t* | wchar_t*
#
#       this replaces the default char* mapping in C for xsd:string.
#       To use C++ std::wstring for xsd:string:
#
#               xsd__string = | std::wstring
#
#       After enabling one of these lines, all XSD strings will be changed in
#       the interface file generated by wsdl2h.  Rerun wsdl2h if necessary.
#       Note that the 'declaration' part above is empta,y as expected.
#
#       When a type binding requires only the usage to be changed and the
#       declaration part must be kept intact, then the declaration part should
#       be specified as an elipsis '...':
#
#               prefix__type = ... | use | ptr-use
#
#       This ensure that the wsdl2h-generated type definition is preserved,
#       while the use and ptr-use are changed.

####### CLASS/STRUCT MEMBER ADDITIONS

#       Additional data and function members can be provided to extend a
#       wsdl2h-generated struct or class.
#
#       Class and struct extensions are of the form:
#
#               prefix__type = $ member-declaration
#
#       For example, to add a constructor and destructor to class myns__record:
#
#               myns__record = $ myns__record();
#               myns__record = $ ~myns__record();

####### TYPE EQUIVALENCES

#       Type equivalence mappings can be given to replace a type with another:
#
#               prefix__type1 == prefix__type2
#
#       This replaces 'prefix__type1' by 'prefix__type2' in the wsdl2h output.
#
#       For example:
#
#               SOAP_ENC__boolean == xsd__boolean
#
#       replaces 'SOAP_ENC__boolean' with the C/C++ type information that
#       corresponds to `xsd__boolean' which is 'bool' for C++.
#
#       Target C/C++ type names (names without prefix) can also be replaced:
#
#               float == double
#
#       which replaces all 'float' with 'double' in the wsdl2h output. Beware
#       that replacing types may lead to xsi:type mismatches and SOAP
#       encoding id-ref mismatches when parsing inbound XML messages. However,
#       this is not a problem when using XML and doc/lit SOAP instead of
#       RPC-encoded SOAP and when mapping schema root elements to their types,
#       for example the WCF serialization root element remappings defined
#       further below.

####### BUILT-IN VARIABLES

#       The variable '$CONTAINER' defines the container to emit in the
#       generated declarations, which is std::vector by default.  For example,
#       to change containers to std::list:
#
#               $CONTAINER = std::list
#
#       To remove containers, use wsdl2h option -s (removes std::string also,
#       you can re-introduce std::string with xsd__string = | std::string).
#
#       The variable '$POINTER' defines the smart pointer to emit in the
#       generated declarations, replacing '*'. For example:
#
#               $POINTER = std::shared_ptr
#
#       Not all pointers in the generated output are replaced by smart
#       pointers by wsdl2h, such as pointers as union members and pointers
#       as struct/class members that point to arrays of values.
#
#       The variable '$SIZE' defines the type of array sizes, which is int by
#       default.  For example, to change array size types to size_t:
#
#               $SIZE = size_t
#
#       Permissible types are int and size_t.  This variable does not affect
#       the size of SOAP-encoded arrays, xsd__hexBinary and xsd__base64Binary
#       types, which is always int.
 
####### USER-DEFINED CONTENT

#       Any other content to be included in the generated header file can be
#       provided by enclosing it within brackets [ and ]. These brackets MUST
#       appear at the start of a new line.
#
#       For example, to add an #import directive to the wsdl2h-generated output:
#
#       [
#       #import "wsa5.h"
#       ]

#-------------------------------------------------------------------------------
#gSOAP XML Web services tools
#Copyright (C) 2000-2015, Robert van Engelen, Genivia Inc. All Rights Reserved.
#This software is released under one of the following two licenses:
#GPL.
#-------------------------------------------------------------------------------
#A commercial use license is available from Genivia, Inc., contact@genivia.com
#-------------------------------------------------------------------------------

[
// Reminder: Modify typemap.dat to customize the header file generated by wsdl2h
]

#       Remember: type bindings are given on a single line (use \ to continue
#       with the next line). Here is an example binding for the XSD int type
#       that maps to an 'int':
# xsd__int      = | int

#       To use regular char* strings instead of std::string, use:
# xsd__string   = | char* | char*

#       For char* serialized with xsi:type when using soapcpp2 option -t, use:
# xsd__string   = typedef char *xsd__string; | xsd__string | xsd__string

#       The following mapping is internally applied by wsdl2h for C (not C++):
#       (assuming option -e is used to remove the xsd__boolean__ name prefix)
# xsd__boolean  = enum xsd__boolean { false_, true_ }; | enum xsd__boolean

#       Uncomment the line below to use __int128_t for xsd:integer instead of
#       mapping xsd:integer to string.
#       Then rerun wsdl2h and also compile and link custom/int128.c
# xsd__integer = #import "custom/int128.h" | xsd__integer
#
#       Or if the xsd:integer value range is bounded to int64_t, then:
# xsd__integer = typedef LONG64 xsd__integer;
#
#       Also, to enable XSD integer types that are restrictions of xsd:integer
#       to be mapped to int128 or LONG64, uncomment:
# xsd__nonNegativeInteger = typedef xsd__integer xsd__nonNegativeInteger 0 :   ;
# xsd__nonPositiveInteger = typedef xsd__integer xsd__nonPositiveInteger   : 0 ;
# xsd__positiveInteger    = typedef xsd__integer xsd__positiveInteger    1 :   ;
# xsd__negativeInteger    = typedef xsd__integer xsd__negativeInteger      : -1;

#       Uncomment the line below to use long double for xsd:decimal instead of
#       mapping xsd:decimal to string.
#       Then rerun wsdl2h and also compile and link custom/long_double.c.
# xsd__decimal = #import "custom/long_double.h" | long double
#
#       Or if your system supports __float128 then you can use:
# xsd__decimal = #import "custom/float128.h" | xsd__decimal
#
#       Or if the xsd:decimal value range is bounded to double, then:
# xsd__decimal = typedef double xsd__decimal;

#       Uncomment the line below to use struct tm instead of time_t xsd:dateTime
#       Then rerun wsdl2h and also compile and link custom/struct_tm.c.
# xsd__dateTime = #import "custom/struct_tm.h" | xsd__dateTime

#       Uncomment the line below to use timeval with usec precision xsd:dateTime
#       Then rerun wsdl2h and also compile and link custom/struct_timeval.c.
# xsd__dateTime = #import "custom/struct_timeval.h" | xsd__dateTime

#       Uncomment the line below to use std::chrono::system_clock::time_point
#       for xsd:dateTime.
#       Then rerun wsdl2h and also compile and link custom/chrono_time_point.c.
# xsd__dateTime = #import "custom/chrono_time_point.h" | xsd__dateTime

#       Uncomment the line below to use struct tm for xsd:date instead of
#       mapping xsd:date to string.
#       Then rerun wsdl2h and also compile and link custom/struct_tm_date.c.
# xsd__date = #import "custom/struct_tm_date.h" | xsd__date

#       Uncomment the line below to use LONG64 int for xsd:duration instead of
#       mapping xsd:duration to string (in milliseconds precision).
#       Then rerun wsdl2h and also compile and link custom/duration.c.
#
# xsd__duration = #import "custom/duration.h" | xsd__duration

#       Uncomment the line below to use C++11 std::chrono::nanoseconds for
#       xsd:duration instead of mapping xsd:duration to string.
#       Then rerun wsdl2h and also compile and link custom/chrono_duration.cpp.
# xsd__duration = #import "custom/chrono_duration.h" | xsd__duration

#       Uncomment the line below to use ULONG64 int for xsd:time instead of
#       mapping xsd:time to string (also comes with high usec precision)
#       Then rerun wsdl2h and also compile and link custom/time.c
# xsd__time = #import "custom/long_time.h" | xsd__time

#       When compiling WITH_LEAN there is no hexBinary serializer. You can
#       remap the hexBinary type to a string as follows:
# xsd__hexBinary = | char*

#       When wsdl2h option -d is used, xsd:any is mapped to xsd__anyType DOM
#       declared in dom.h and implemented in dom.c/dom.cpp. You can remap
#       xsd:any, for example to a pointer to a DOM node as follows:
# xsd__any = | xsd__anyType*

#       When SOAP 1.2 Faults should carry multiple SOAP_ENV__Text elements with
#       xml:lang attributes, then remap SOAP_ENV__Reason as follows:
# [
# struct SOAP_ENV__Reason
# {
#   char *SOAP_ENV__Text; // at least one SOAP-ENV:Text for the gSOAP engine
#   $int size;
#   struct SOAP_ENV__Text *SOAP_ENV__Text_; // array of more SOAP-ENV:Text
# }; 
# struct SOAP_ENV__Text
# {
#   char *__item;
#   @char *xml__lang;
# };
# ]

#       SOAP-ENV mapping. Note that SOAP Body content is mapped to an XML
#       string. Use xsd__anyType instead of _XML to use a DOM instead.

SOAP_ENV__Envelope      = struct SOAP_ENV__Envelope { struct SOAP_ENV__Header *SOAP_ENV__Header; _XML SOAP_ENV__Body; }; | struct SOAP_ENV__Envelope
SOAP_ENV__Header        = | struct SOAP_ENV__Header
SOAP_ENV__Fault         = | struct SOAP_ENV__Fault
SOAP_ENV__Detail        = | struct SOAP_ENV__Detail
SOAP_ENV__Code          = | struct SOAP_ENV__Code
SOAP_ENV__Subcode       = | struct SOAP_ENV__Subcode
SOAP_ENV__Reason        = | struct SOAP_ENV__Reason

#       SOAP-ENV mapping when using C++ namespaces with soapcpp2 option -q
#       THE FOLLOWING DEFINITIONS SHOULD ONLY BE USED WHEN COMPILATION ERRORS
#       OCCUR.  Remove the previous SOAP_ENV__Envelope, SOAP_ENV__Header and
#       SOAP_ENV__Fault, then enable the following definitions:

# SOAP_ENV__Envelope    = struct SOAP_ENV__Envelope { struct SOAP_ENV__Header_ *SOAP_ENV__Header; _XML SOAP_ENV__Body; }; | struct SOAP_ENV__Envelope
# SOAP_ENV__Header      = struct SOAP_ENV__Header_ { /* place SOAP Header elements here, if any */ }; | struct SOAP_ENV__Header_
# SOAP_ENV__Fault               = \
# struct SOAP_ENV__Fault_\
# {\
#   char *faultcode;\
#   char *faultstring;\
#   char *faultactor;\
#   struct SOAP_ENV__Detail_ *detail;\
#   struct SOAP_ENV__Code_ *SOAP_ENV__Code;\
#   struct SOAP_ENV__Reason_ *SOAP_ENV__Reason;\
#   char *SOAP_ENV__Node;\
#   char *SOAP_ENV__Role;\
#   struct SOAP_ENV__Detail_ *SOAP_ENV__Detail;\
# };\
# struct SOAP_ENV__Detail_\
# {\
#   char *__any;\
#   int __type;\
#   void *fault;\
# };\
# struct SOAP_ENV__Code_\
# {\
#   char *SOAP_ENV__Value;\
#   struct SOAP_ENV__Code_ *SOAP_ENV__Subcode_;\
# };\
# struct SOAP_ENV__Reason_\
# {\
#   char *SOAP_ENV__Text;\
# };\
# | struct SOAP_ENV__Fault_

#       Older gSOAP versions prior to 2.8.83 used a simple SOAP_ENC__Array type
#       which can be re-enabled by uncommenting this line:
# SOAP_ENC__Array = | struct { _XML *__ptr; int __size; } | struct { _XML *__ptr; int __size; }

#       Temporary URI

tempuri = "http://tempuri.org/"

#       Empty URI

empty   = ""

#       .NET WCF DataContract Serialization Schema

ser     = <http://schemas.microsoft.com/2003/10/Serialization/>
arr     = "http://schemas.microsoft.com/2003/10/Serialization/Arrays"

#       .NET WCF DataContract Serialization Schema root element remappings

_ser__anyURI            == xsd__anyURI
_ser__boolean           == xsd__boolean
_ser__base64Binary      == xsd__base64Binary
_ser__byte              == xsd__byte
_ser__dateTime          == xsd__dateTime
_ser__decimal           == xsd__decimal
_ser__double            == xsd__double
_ser__float             == xsd__float
_ser__int               == xsd__int
_ser__long              == xsd__long
_ser__QName             == xsd__QName
_ser__short             == xsd__short
_ser__string            == xsd__string
_ser__unsignedByte      == xsd__unsignedByte
_ser__unsignedInt       == xsd__unsignedInt
_ser__unsignedLong      == xsd__unsignedLong
_ser__unsignedShort     == xsd__unsignedShort

#       .NET WCF ser:anyType represents an object (see import/ser.h):

_ser__anyType   = | struct __ser__anyType | struct __ser__anyType

#       .NET WCF ser:char element and type represents a Unicode character

_ser__char      = | int
ser__char       = | int

#       .NET WCF ser:duration root element and type maps to xsd:duration

_ser__duration  == xsd__duration
ser__duration   == xsd__duration

#       .NET WCF ser:guid pattern = "[\da-fA-F]{8}-[\da-fA-F]{4}-[\da-fA-F]{4}-[\da-fA-F]{4}-[\da-fA-F]{12}"

_ser__guid      = | char*
ser__guid       = | char*

#       .NET WCF samples

mssamh  = "http://Microsoft.Samples.Http"
mssamhi = "http://Microsoft.Samples.Http/Imports"

mssamt  = "http://Microsoft.Samples.TransportSecurity"
mssamti = "http://Microsoft.Samples.TransportSecurity/Imports"

mssamm  = "http://Microsoft.Samples.MessageSecurity"
mssammi = "http://Microsoft.Samples.MessageSecurity/Imports"

mssadh  = "http://Microsoft.Samples.DualHttp"
mssadhi = "http://Microsoft.Samples.DualHttp/Imports"

#       MTOM xop and xmime are imported from xop.h, xmime.h, and xmlmime.h:
#       Note: changed xmlmime to xmime to avoid other MTOM tools from
#       complaining that 'xml' is reserved.

xop     = <http://www.w3.org/2004/08/xop/include>
xmime   = <http://www.w3.org/2004/06/xmlmime>
xmime4  = <http://www.w3.org/2004/11/xmlmime>
xmime5  = <http://www.w3.org/2005/05/xmlmime>

#       xop:Include is imported from xop.h and redefined as _xop__Include:

xop__Include = #import "xop.h" | _xop__Include

#       xmime/xmlmime:contentType attribute is a string:

_xmime__contentType     = | char* | char*
_xmime4__contentType    = | char* | char*
_xmime5__contentType    = | char* | char*

#       exc-c14n

c14n    = <http://www.w3.org/2001/10/xml-exc-c14n#>

#       WS-Addressing (2003, 2004, and 2005 schemas)
#       See import/wsa.h, import/wsa3.h etc for definitions and code examples
#       The API is defined in plugin/wsaapi.c, plugin/wsaapi3.c, etc.

wsa     = <http://schemas.xmlsoap.org/ws/2004/08/addressing>
wsa3    = <http://schemas.xmlsoap.org/ws/2003/03/addressing>
wsa4    = <http://schemas.xmlsoap.org/ws/2004/03/addressing>
wsa5    = <http://www.w3.org/2005/08/addressing>

#       The types below should not use pointers, so we add a 3rd column:

_wsa__Action    = | | _wsa__Action
_wsa__MessageID = | | _wsa__MessageID
_wsa__To        = | | _wsa__To

_wsa3__Action    = | | _wsa3__Action
_wsa3__MessageID = | | _wsa3__MessageID
_wsa3__To        = | | _wsa3__To

_wsa4__Action    = | | _wsa4__Action
_wsa4__MessageID = | | _wsa4__MessageID
_wsa4__To        = | | _wsa4__To

_wsa5__Action    = | | _wsa5__Action
_wsa5__MessageID = | | _wsa5__MessageID
_wsa5__To        = | | _wsa5__To

#       WS-ReliableMessaging 1.1 and 1.0 (and obsolete WS-Reliability 2004)

wsrm    = <http://docs.oasis-open.org/ws-rx/wsrm/200702>
wsrm5   = <http://schemas.xmlsoap.org/ws/2005/02/rm>
wsrm4   = <http://docs.oasis-open.org/wsrm/2004/06/ws-reliability-1.1.xsd>

#       WS-Discovery 1.1 (2009/01) and 1.0 (2004/08 with WS-Addressing)
#       To upgrade WS-Discovery to WS-Addressing 2005/08, uncomment wsdd5:

wsdd    = <http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01>
#wsdd5  = <http://schemas.xmlsoap.org/ws/2005/04/discovery>
wsdd10  = <http://schemas.xmlsoap.org/ws/2005/04/discovery>

wsdd5__HelloType                = | wsdd__HelloType
wsdd5__ByeType                  = | wsdd__ByeType
wsdd5__ProbeType                = | wsdd__ProbeType
wsdd5__ProbeMatchesType         = | wsdd__ProbeMatchesType
wsdd5__ProbeMatchType           = | wsdd__ProbeMatchType
wsdd5__ResolveType              = | wsdd__ResolveType
wsdd5__ResolveMatchesType       = | wsdd__ResolveMatchesType
wsdd5__ResolveMatchType         = | wsdd__ResolveMatchType
wsdd5__ScopesType               = | wsdd__ScopesType
wsdd5__SecurityType             = | wsdd__SecurityType
wsdd5__SigType                  = | wsdd__SigType
wsdd5__AppSequenceType          = | wsdd__AppSequenceType

wsdd10__HelloType               = | wsdd__HelloType
wsdd10__ByeType                 = | wsdd__ByeType
wsdd10__ProbeType               = | wsdd__ProbeType
wsdd10__ProbeMatchesType        = | wsdd__ProbeMatchesType
wsdd10__ProbeMatchType          = | wsdd__ProbeMatchType
wsdd10__ResolveType             = | wsdd__ResolveType
wsdd10__ResolveMatchesType      = | wsdd__ResolveMatchesType
wsdd10__ResolveMatchType        = | wsdd__ResolveMatchType
wsdd10__ScopesType              = | wsdd__ScopesType
wsdd10__SecurityType            = | wsdd__SecurityType
wsdd10__SigType                 = | wsdd__SigType
wsdd10__AppSequenceType         = | wsdd__AppSequenceType

#       WS-Policy

wsp     = <http://schemas.xmlsoap.org/ws/2004/09/policy>

#       WS-SecureConversation 1.4

wsc     = <http://docs.oasis-open.org/ws-sx/ws-secureconversation/200512>
wsc2    = <http://schemas.xmlsoap.org/ws/2005/02/sc>

#       WS-Trust 1.2 and 1.3

wst     = <http://docs.oasis-open.org/ws-sx/ws-trust/200512>
# Some WSDLs use the incorrect URI (below), if so, replace the above with:
# wst     = <http://docs.oasis-open.org/ws-sx/ws-trust/200512/>
wst2    = <http://schemas.xmlsoap.org/ws/2005/02/trust>

wst__RequestSecurityToken                   = | wst__RequestSecurityTokenType*
wst__RequestSecurityTokenResponse           = | wst__RequestSecurityTokenResponseType*
wst__RequestSecurityTokenCollection         = | wst__RequestSecurityTokenCollectionType*
wst__RequestSecurityTokenResponseCollection = | wst__RequestSecurityTokenResponseCollectionType*

wst2__RequestSecurityToken                   = | wst__RequestSecurityTokenType*
wst2__RequestSecurityTokenResponse           = | wst__RequestSecurityTokenResponseType*
wst2__RequestSecurityTokenCollection         = | wst__RequestSecurityTokenCollectionType*
wst2__RequestSecurityTokenResponseCollection = | wst__RequestSecurityTokenResponseCollectionType*

#       SAML bindings

saml1   = <urn:oasis:names:tc:SAML:1.0:assertion>
saml2   = <urn:oasis:names:tc:SAML:2.0:assertion>

#       WS-Security wsse 2004 v1.0 and 1.1 and old wsse 2002 schema

wsse11  = <http://docs.oasis-open.org/wss/oasis-wss-wssecurity-secext-1.1.xsd>
wsse    = <http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd>
wsse2   = <http://schemas.xmlsoap.org/ws/2002/12/secext>

_wsse2__Security == _wsse__Security
wsse2__Security == wsse__Security

#       wsu 2004

wsu     = <http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd>

_wsu__Id                = | char*
_wsu__Created           = | time_t
_wsu__Expires           = | time_t

wsu__AttributedDateTime = | time_t
wsu__AttributedURI      = | char*

#       Bindings for ds and xenc for WS-Security protocols:

ds      = <http://www.w3.org/2000/09/xmldsig#>
xenc    = <http://www.w3.org/2001/04/xmlenc#>

#       xlink

xlink   = "http://www.w3.org/1999/xlink"

#       wsrp routing protocol (deprecated)

wsrp    = <http://schemas.xmlsoap.org/rp/>

#       BPEL 2.0

bpel    = "http://docs.oasis-open.org/wsbpel/2.0/process/executable"
bpelabs = "http://docs.oasis-open.org/wsbpel/2.0/process/abstract"
plnk    = "http://docs.oasis-open.org/wsbpel/2.0/plnktype"
sref    = "http://docs.oasis-open.org/wsbpel/2.0/serviceref"
vprop   = "http://docs.oasis-open.org/wsbpel/2.0/varprop"

#       ONVIF recommended prefixes as per 8/20/12
#       http://www.onvif.org/onvif/ver10/device/wsdl/devicemgmt.wsdl
#       http://www.onvif.org/onvif/ver10/event/wsdl/event.wsdl
#       http://www.onvif.org/onvif/ver10/display.wsdl
#       http://www.onvif.org/onvif/ver10/deviceio.wsdl
#       http://www.onvif.org/onvif/ver20/imaging/wsdl/imaging.wsdl
#       http://www.onvif.org/onvif/ver10/media/wsdl/media.wsdl
#       http://www.onvif.org/onvif/ver20/ptz/wsdl/ptz.wsdl
#       http://www.onvif.org/onvif/ver10/receiver.wsdl
#       http://www.onvif.org/onvif/ver10/recording.wsdl
#       http://www.onvif.org/onvif/ver10/search.wsdl
#       http://www.onvif.org/onvif/ver10/network/wsdl/remotediscovery.wsdl
#       http://www.onvif.org/onvif/ver10/replay.wsdl
#       http://www.onvif.org/onvif/ver20/analytics/wsdl/analytics.wsdl
#       http://www.onvif.org/onvif/ver10/analyticsdevice.wsdl   
#       http://www.onvif.org/onvif/ver10/schema/onvif.xsd

tds     = "http://www.onvif.org/ver10/device/wsdl"
tev     = "http://www.onvif.org/ver10/events/wsdl"
tls     = "http://www.onvif.org/ver10/display/wsdl"
tmd     = "http://www.onvif.org/ver10/deviceIO/wsdl"
timg    = "http://www.onvif.org/ver20/imaging/wsdl"
trt     = "http://www.onvif.org/ver10/media/wsdl"
tptz    = "http://www.onvif.org/ver20/ptz/wsdl"
trv     = "http://www.onvif.org/ver10/receiver/wsdl"
trc     = "http://www.onvif.org/ver10/recording/wsdl"
tse     = "http://www.onvif.org/ver10/search/wsdl"
trp     = "http://www.onvif.org/ver10/replay/wsdl"
tan     = "http://www.onvif.org/ver20/analytics/wsdl"
tad     = "http://www.onvif.org/ver10/analyticsdevice/wsdl"
tas     = "http://www.onvif.org/ver10/advancedsecurity/wsdl"
tdn     = "http://www.onvif.org/ver10/network/wsdl"
tt      = "http://www.onvif.org/ver10/schema"

#       to extend tt__EventFilter with TopicExpression element (for C):
# tt__EventFilter = $ struct wsnt__TopicExpressionType *wsnt__TopicExpression;
#       to extend tt__EventFilter with TopicExpression element (for C++):
# tt__EventFilter = $ wsnt__TopicExpressionType *wsnt__TopicExpression;

#       to extend _tds__Service_Capabilities with trt:ProfileCapabilities element (for C):
# tds__Service_Capabilities = $ struct trt__ProfileCapabilities* trt__ProfileCapabilities;
#       to extend _tds__Service_Capabilities with trt:ProfileCapabilities element (for C++):
# _tds__Service_Capabilities = $ trt__ProfileCapabilities* trt__ProfileCapabilities_;

#       to extend trt__ProfileCapabilities with @Rotation attribute (for C):
# trt__ProfileCapabilities = $ @enum xsd__boolean Rotation;
#       to extend trt__ProfileCapabilities with @Rotation attribute (for C++):
# trt__ProfileCapabilities = $ @bool Rotation;

#       OASIS recommended prefixes

wsnt    = "http://docs.oasis-open.org/wsn/b-2"
wsntw   = "http://docs.oasis-open.org/wsn/bw-2"
wsrfbf  = "http://docs.oasis-open.org/wsrf/bf-2"
wsrfr   = "http://docs.oasis-open.org/wsrf/r-2"
wsrfrw  = "http://docs.oasis-open.org/wsrf/rw-2"
wstop   = "http://docs.oasis-open.org/wsn/t-1"

#       TR-069 recommended prefixes

cwmp = "urn:dslforum-org:cwmp-1-1"
cwmp = "urn:dslforum-org:cwmp-1-2"
lwn  = "urn:broadband-forum-org:cwmp:lwnotif-1-0"
dm   = "urn:broadband-forum-org:cwmp:datamodel-1-5"
dmr  = "urn:broadband-forum-org:cwmp:datamodel-report-0-1"
dt   = "urn:broadband-forum-org:cwmp:devicetype-1-3"
dtf  = "urn:broadband-forum-org:cwmp:devicetype-features"
xmpp = "urn:broadband-forum-org:cwmp:xmppConnReq-1-0"
bdc  = "urn:broadband-forum-org:ipdr:tr-232-1-0"
ipdr = "http://www.ipdr.org/namespaces/ipdr"

#       XMPP and jabber protocols (a selection)

stream  = "http://etherx.jabber.org/streams"
iqrpc   = "jabber:iq:rpc"
xdata   = "jabber:x:data"
iqlast  = "jabber:iq:last"

#       XHTML prefix and recommended types

xhtml = "http://www.w3.org/1999/xhtml"

xhtml__Number = | unsigned int
xhtml__Pixels = | unsigned int

#       HL7 FHIR prefix
#       When using FHIR you may want to use XHTML as a DOM instead of XML data
#       binding resulting in lots of code, by uncommenting the following line:
# xhtml = <http://www.w3.org/1999/xhtml>
#       with this line uncommented, create an xhtml.h file with the following:
= #import "dom.h"
# typedef xsd__anyType _xhtml__div;

fhir = "http://hl7.org/fhir"

#       Prefix bindings for WhiteMesa interoperability testing round 2:

i       = "http://soapinterop.org/"
s       = "http://soapinterop.org/xsd"

#       Prefix bindings for Amazon AWS S3 Web Services:

aws     = "urn:PI/DevCentral/SoapService"
s3      = "http://s3.amazonaws.com/doc/2006-03-01/"

_s3__CreateBucketResponse = $ s3__CreateBucketResult* CreateBucketResponse;
_s3__CopyObjectResponse   = $ s3__CopyObjectResult* CopyObjectResponse;

#       Prefix bindings for Exchange Web Services

ewsmsg  = "http://schemas.microsoft.com/exchange/services/2006/messages"
ewstype = "http://schemas.microsoft.com/exchange/services/2006/types"

#       Prefix binding for Mappoint Web services:

mpt     = "http://s.mappoint.net/mappoint-30/"

#       Prefix binding for XLIFF 2.0

xliff = "urn:oasis:names:tc:xliff:document:2.0"

xliff__priorityValue = typedef int xliff__priorityValue 1:10;
